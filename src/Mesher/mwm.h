#ifndef _MWM_H_
#define _MWM_H_

/******************************************************************
*
*	MWM for C++
*
*	Copyright (C) Walter Steffe` 2004-2004
*
*	File:	mwm.h
*
******************************************************************/

#define TETMODELTYPE 'y'

#include<Malloc.h>
#include<string.h>
#include<math.h>
#include<List.h>
#include<Tree.h>
#include<Message.h>
#include <DataBase.h>
#include "MVertex.h"
#include "GEdge.h"


#include<buffer.h>
#include<map>
#include<set>
#include<string>
#include<vector>
#include<bitset>
#include<algorithm>

#ifndef PIG
#define PIG 3.14159265
#endif

#ifndef MIN
#define MIN(a,b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b)  (((a) > (b)) ? (a) : (b))
#endif

#define GEOMTOLERANCE      1.e-8


#define DIELECTRIC         1
#define WAVEGUIDE          2
#define BOUNDARYCOND       3
#define UPPERFACE	   4
 #define HOLE               5



namespace MWM {

int permu_sign(int n, int *permu ); // permu indexes starting at 0
void IsortAndPermu(int n, int *data, int *ipermu);


//-----------------------------
class Vertex {
public:
  DB::str_t    name;
  int      Index;
  int      onPEC;
  int      onPMC;
  int      onEC;
  int      shared;
  Vertex(const DB::str_t name);
};

//-----------------------------
class Curve {
public:
  DB::str_t     name;
  int           Index;
  int           onPEC;
  int           onPMC;
  int           onWG;
  int           onEC;
  int           onLP;
// Restricted span tree after having identified electric potentials of all PEC surfaces
  int           shared; 
  int           triaVNum;
  int           instNum;
  double 	length;
  GEdge         *ge;
  int           masterSign;
  Vertex        *beg, *end;
  DB::Vec<double>   points;
//  DB::Vec<double>   pointsU;
  DB::Vec<double>   tangents;
  MVertex *  mesh_vertices(int i);
  MVertex *  master_mesh_vertices(int i);
  Curve(const DB::str_t name);
  void setGEdge(GEdge * ge_, int GMSH_Esign);
  void setMasterMesh();
  void setMesh();
//  void getName(char *str, int maxlen);
};
//-----------------------------


//-----------------------------
class Surface {
public:
//------Data generated by Parser
  DB::str_t     name;
  int           Index;
  bool		planar;
  DB::Vec<double>   points;
//  DB::Vec<double>   pointsUV;
  DB::Vec<int>	triangles;
  DB::Vec<int>	triaCenters;
  std::vector<std::vector<int>>  curvePoints;
  int           NumOfCurves;
  GFace         *gf;
  int           masterSign;
  std::vector<MVertex *>  mesh_vertices;
  DB::Vec<int>      BdrCond;
  DB::Vec<int>      curveSgn;
  Curve         **curves;
  int           *contPart; //The Cont Curves are tagged with a set of indices which
                           //represent the connected parts of the contour
  int           *triaEdges;
//-----------------------------
//
//----------------------- trough private func makeCurves:
  DB::Vec<int>      *curveP;
//----------------------- trough private func  makePermu
  int triaVnum;
  int triaVinum;
  int NCP;
  int NSUPi;
  int *Permu; //Points Permutation so that tria vertices come firsts
//
//***** public functions:
  Surface();
  ~Surface();
  int GFaceSign(GFace *gf);
  void setGFace(GFace * gf_);
  void setMasterMesh();
  void setMesh();
  void checkMesh();
  void checkMasterMesh();
};
//-------------------------------------


int fcmp_Surface(const void *a, const void *b);
int fcmp_Curve(const void *a, const void *b);
int fcmp_Vertex(const void *a, const void *b);
int fcmp_3d(const void *a, const void *b);
int fcmp_CurveByPoints(const void *a, const void *b);

enum PointEdgeProperties {ONPEC=0, ONPMC=1,  ONEC=2, ONWG=3, ONETREE=4, ONHTREE=5 };

class PointProp{
 public:
 std::bitset<8> properties;
 void set(PointEdgeProperties prop){
   properties.set(prop);
 }
 void clear(PointEdgeProperties prop){
   properties.reset(prop);
 }
 int is(PointEdgeProperties prop){
  return properties.test(prop);
 }
};


class Mesh{
public:
  DB::Tree_T  *surfaces, *curves, *vertices;
  int  MaxVertexIndex, MaxCurveIndex, MaxSurfaceIndex;
  int  NumOfVertexV;
//------------------------
  Mesh();
  ~Mesh();
  void addSurface   (Surface*   s);
  void addCurve     (Curve*     c);
  Vertex    *insertVertex (const DB::str_t name);
  Curve     *insertCurve  (const DB::str_t name, const char* beg=nullptr, const char *end=nullptr );
  Surface   *FindSurface(const DB::str_t name);
  Curve     *FindCurve(const DB::str_t name);
};

void newMesh();

}//namespace
 
#endif
